let

true = \x.\y. x;
false = \x.\y. y;
ifthenelse = \a.\b.\c. a b c;
not = \a. a false true;
and = \a.\b. a b false;
or = \a.\b. a true b;
implies = \a.\b. a b true;
ifandonlyif = \a.\b. a b (not b);
succ = \n.\p.\q. p (n p q);
plus = \m.\n.\p.\q. m p (n p q);
times = \m.\n.\p.\q. m (n p) q;
power = \m.\n. n m;
isZero = \n. n (\x. false) true;
pair = \m.\n.\b. b m n;
fst = \p. p true;
snd = \p. p false;
shiftInc = \p. pair (snd p) (succ (snd p));
pred = \n. fst (n shiftInc (pair 0 0));
empty = \x. true;
cons = \h.\t. pair h t;
isEmpty = \l. l (\x.\y. false);
head = fst;
tail = snd;
Y = \f. (\x. f (x x)) (\x. f (x x));

-- Funções Genéricas Criadas

minus = \p.\q. q pred p;
divide = Y divideX;
modX = \X.\p.\q.
	ifthenelse (le p q)
		p
		(X (minus p q) q);
mod = Y modX;
divideX = \X.\p.\q.
	ifthenelse (le p q)
		0
		(succ (X (minus p q) q));
geq = \p.\q. isZero (minus q p);
leq = \p.\q. isZero (minus p q);
ge = \p.\q. not (leq p q);
le = \p.\q. not (geq p q);
eq = \p.\q. and (qeq p q) (geq q p);
neq = \p.\q. not (eq p q);

-- Questão 1:

listDigitX = \X.\p.
	ifthenelse isZero p
		(cons
			0
			empty)
		(cons
			(divide p 10)
			(X (divide p 10)));
listDigit = Y listDigitX;
listLastX = \X.\l.
	ifthenelse (isEmpty (tail l))
		(head l)
		(X (tail l));
listLast = Y listLastX;
listReverseX = \X.\l.
	ifthenelse (isEmpty l)
		empty
		(cons
			(listLast l)
			(X (tail l)));
listReverse = Y listReverseX;
listEqX = \X.\l.\m.
	or	(and (isEmpty l) (isEmpty m))
		(ifthenelse (eq (head l) (head m))
			(X (tail l) (tail m))
			false);
listEq = Y listEqX;
palin = \p.
	ifthenelse  (le p 10) 
		true
		(listEq	 (listDigit p) (listReverse (listDigit p)));

-- Questão 2:

posicionaX = \X.\h.\t.
	ifthenelse (isEmpty t)
		(cons
			h
			empty)
		(ifthenelse (le h (head t))
			(cons
				h
				t)
			(cons
				(head t)
				(X h (tail t))));
posiciona = Y posicionaF;
ordenaX = \X.\l.
	ifthenelse (isEmpty l)
		empty
		(ifthenelse (isEmpty (tail l))
			(cons
				(head l)
				empty)
			(posiciona (head l) (X (tail l))));
ordena = Y ordenaX;

-- Questão 3:

assinaturaX = \X.\m.
	ifthenelse (le m 10)
		m
		(plus (mod m 10) (X (divide m 10)));
assinatura = Y assinaturaX;

-- Questão 4:

tryraizcubicaX = \X.\m.\n.
	ifthenelse (le n (power (succ m) 3))
		m
		(X (succ m) n);
tryraizcubica = Y tryraizcubicaX;
raizcubica = \n. tryraizcubica 0 n;

-- Questão 5:

fatiaX = \X.\l.\p.\q.
	ifthenelse (or (isEmpty l) (ge p q))
		empty
		(ifthenelse (isZero q)
			(cons
				(head l)
				empty)
			(ifthenelse (isZero p)
				(cons
					(head l)
					(F (tail l) (pred p) (pred q)))
				(X (tail l) (pred p) (pred q))));
fatia = Y fatiaX;

-- Execução:

in

assinatura 12
