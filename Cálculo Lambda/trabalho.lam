let

true = \x.\y. x;
false = \x.\y. y;
ifthenelse = \a.\b.\c. a b c;
not = \a. a false true;
and = \a.\b. a b false;
or = \a.\b. a true b;
implies = \a.\b. a b true;
ifandonlyif = \a.\b. a b (not b);
succ = \n.\p.\q. p (n p q);
plus = \m.\n.\p.\q. m p (n p q);
times = \m.\n.\p.\q. m (n p) q;
power = \m.\n. n m;
isZero = \n. n (\x. false) true;
pair = \m.\n.\b. b m n;
fst = \p. p true;
snd = \p. p false;
shiftInc = \p. pair (snd p) (succ (snd p));
pred = \n. fst (n shiftInc (pair 0 0));
empty = \x. true;
cons = \h.\t. pair h t;
isEmpty = \l. l (\x.\y. false);
head = fst;
tail = snd;
Y = \f. (\x. f (x x)) (\x. f (x x));

-- Questão 1 

minus = \p.\q. q pred p;

geq = \p.\q. (isZero (minus q p));

leq = \p.\q. (isZero (minus p q));

ge = \p.\q. (not (leq p q));

le = \p.\q. (not (geq p q));

eq = \p.\q. and (isZero (minus p q)) (isZero (minus q p));

divF = \X.\p.\q. (ifthenelse (le p q) 0 (succ (X (minus p q) q)));

div = Y divF;

modF = \X.\p.\q. (ifthenelse (le p q) p (X (minus p q) q));

mod = Y modF;

listDigitF = \X.\p. ifthenelse isZero p
			       (cons 0 empty)
			       (cons (div p 10) (X (div p 10)));

listDigit = Y listDigitF;


-- Funções de Lista -----------------

listLastF = \X.\l. ifthenelse (isEmpty (tail l))
			      (head l)
			      (X (tail l));

listLast = Y listLastF;

listReverseF = \X.\l. ifthenelse (isEmpty l)
				 empty
				 (cons (listLast l) (X (tail l)));

listReverse = Y listReverseF;

listEqF = \X.\l.\m. (or	(and (isEmpty l) (isEmpty m))
			(ifthenelse (eq (head l) (head m))
				    (X (tail l) (tail m))
				    false));

listEq = Y listEqF;

----------------------------------------

palin = \p. ifthenelse  (le p 10) 
			true
			(listEq	 (listDigit p) (listReverse (listDigit p)));


-- Questão 2

menorF = \F.\m.\n. ifthenelse (and (isZero m) (not (isZero n)))
                              true
                              (ifthenelse (isZero n)
                                          false
                                          (F (pred m) (pred n)));
menor = Y menorF;

posicionaF = \F.\h.\t. ifthenelse (isEmpty t)
                                  (cons h empty)
                                  (ifthenelse (menor h (head t))
                                              (cons h t)
                                              (cons (head t) (F h (tail t))));
posiciona = Y posicionaF;

ordenaF = \F.\l. ifthenelse (isEmpty l)
                            empty
                            (ifthenelse (isEmpty (tail l))
                                        (cons (head l) empty)
                                        (posiciona (head l) (F (tail l))));
ordena = Y ordenaF;

-- Questão 3

minus = \m. \n. n pred m;

menor2 = \m. \n. isZero (minus (succ m) n);

divF = \F. \m. \n. (\s. (ifthenelse (isZero s)
                                   0
                                   (succ (F (pred s) n))))
                   (minus (succ m) n);
div = Y divF;

assinaturaF = \F. \m. ifthenelse (menor2 m 10)
                                 m
                                 (plus (mod m 10) (F (div m 10)));
assinatura = Y assinaturaF;

-- Questão 4

tryraizcubicaF = \F.\m.\n. ifthenelse (menor n (power (succ m) 3))
                                      m
                                      (F (succ m) n);
tryraizcubica = Y tryraizcubicaF;
raizcubica = \n. tryraizcubica 0 n;

-- Questão 5

fatiaF = \F.\l.\p.\q. 
		(ifthenelse (or (isEmpty l) (ge p q))
			    empty
			    (ifthenelse (isZero q)
					(cons (head l) empty)
					(ifthenelse (isZero p)
						    (cons (head l) (F (tail l) (pred p) (pred q)))
						    (F (tail l) (pred p) (pred q)))));

fatia = Y fatiaF;

-- Teste:

in

assinatura 12
